---
title: "Analysis of Google Play Store Apps"
author: "Minhaz Khan"
date: "January 12, 2019"
output: html_document
---

```{r}
library(tidyverse)
library(lubridate)
library(klaR)
library(broom)
library(tidytext)
library(rpart)
library(rpart.plot)
library(modelr)
```
##Introduction

Have you ever come across an app, saw it had a 4.5 star rating and it described exactly what you were looking for but then found out the app was extremely buggy? After taking a closer look at the app page you find out it has about a thousand installs and only a couple of hundred reviews. Majority of apps in the Google Play store and any app store in general are misleading like this due to several factors such as number of installs and reviews as mentioned above along with when it was last updated, the OS version it supports and etc. In this analysis we will be exploring the overall rating of the app. 

#Reading in the Data
```{r}
apps = read_csv("googleplaystore.csv")
head(apps)
```

#Average rating of each genre

Filtered out the missing rating values and stored them in a new data frame which we will use for the rest of the analysis.

```{r}
apps %>% filter(Rating != 'NaN') -> true_apps
true_apps %>% group_by(Genres) %>% summarise(avg=mean(Rating))
```
Most genres have a decent ratng around 4.0 but majority of these genres are similar to each other, something that we will simplify later on.

Getting a glimpse of the data to convert the numerical data from being characters
```{r}
glimpse(true_apps)
```
We have a lot of character variables here that we need as numbers, we will be converting them below

##Seperating Numerical and Character values from columns
```{r}
true_apps %>% filter(Size != "Varies with device") %>% 
  separate(Size, c("Size","Type"), sep = -1, convert = TRUE) %>% 
  separate(Installs, c("Installs","Symbol"), sep = -1, convert = TRUE) %>% drop_na() -> apps2

apps2$Price = parse_number(apps2$Price)

apps2$Symbol = NULL
apps2$Category = NULL
apps2$`Current Ver`= NULL
```
Removed Symbol because it was just character; removed category because it was the same as genre, removed Current Version because it isn't as necessary as when the app was last updated. Kept Android version because exploring app compatibility with OS might be interesting.

#Converting character values to numeric
The convert parameter in seperate didn't work so here we are manually converting Installs and Size to numeric variables
```{r}
apps2$Installs = as.numeric(gsub(",","",apps2$Installs))
apps2$Size = as.numeric(as.character(apps2$Size))
glimpse(apps2)
```

#Converting dates
```{r}

apps2$`Last Updated` = gsub(",","",apps2$`Last Updated`)
apps2 %>% mutate(`Last Update` = mdy(`Last Updated`)) -> apps2

```

Attempting to factor prices as paid or not:
```{r}
apps2 %>% mutate(Price = case_when(
                              Price == 0 ~ Price, 
                              Price > 0 ~ Price/Price,
                              TRUE ~ NA_real_)) -> apps2

```

#Converting kilobyte app size
```{r}
apps2 %>% mutate(SIZE = case_when(
                              Type == "M" ~ Size, 
                              Type == "k" ~ Size/1024,
                              TRUE ~ NA_real_)) -> apps2

apps2 %>% separate_rows(Genres, sep = ";", convert = FALSE) -> apps2

apps2$Size = NULL
apps2$Type = NULL
```
The case_when function helped out here because values in the columns to be changed aren't the same.


#Some Descriptive Statistics
```{r}
apps2 %>% group_by(Genres) %>% summarise(m=mean(Rating))
(apps_aov = aov(Rating~SIZE+Installs+Price+Reviews+Genres+`Content Rating`+`Last Update`, data = apps2))

summary(apps_aov)

```
From the results of the analysis of Variance we observe there is a significant difference in the means in all the categories except for Content Rating, given their p-values are far less than 0.05.

##Graphing the relationship between the rating and other numerical factors
```{r}
ggplot(apps2, aes(Rating,log(Installs)))+geom_point()+xlim(0,5)+ylim(min(log(apps2$Installs)),max(log(apps2$Installs)))+geom_smooth()
ggplot(apps2, aes(Rating,log(Reviews)))+geom_point()+xlim(0,5)+ylim(min(log(apps2$Reviews)),max(log(apps2$Reviews)))+geom_smooth()
ggplot(apps2, aes(Rating,SIZE))+geom_point()+xlim(0,5)+ylim(min(apps2$SIZE),max(apps2$SIZE))+geom_smooth()
ggplot(apps2, aes(Rating,Price))+geom_point()+xlim(0,5)+ylim(min(apps2$Price),max(apps2$Price))+geom_smooth()
#appplot + ylim(0,5) + xlim(1,1.0e+09)
#appplot + ylim(0,5)
```
Effective rating goes down after reaching its peak in proportion to the categories above as expected. This highlights the fact that good apps exist but doesn't get much attention or the ratings and reviews are fabricated.

## Regression Models

#Fixing duplicate Genres under similar terms
```{r}
apps2 %>% mutate(Genres = case_when(
                              Genres == "Educational" ~ "Education", 
                              Genres == "Music & Audio" ~ "Music",
                              Genres == "Music & Video" ~ "Music",
                              TRUE ~ Genres)) -> apps2
```


```{r}
appreg = lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Genres+Price, data = apps2, weights = Installs)
summary(appreg)
```
Taking the log of Installs and Reviews and weighing it with the Installs helped increase the R squared to about 53% from under 1%
```{r}
ggplot(appreg, aes(x=.fitted, y=.resid))+geom_point()+geom_smooth()
```
This is a peculiar residual plot due to the fact there is a specific range for the ratings (0-5), there seems to be a certain pattern in its overall shape but it's difficult to judge the overall randomness.

##Kmeans for Genres

Here we attempt K-means clustering to create our mega genres to reduce the overwhelming number of genres we have. We are gonna cluster them into 10 specific genres as we feel it's a good amount of variety.
```{r}
#Here we use the kmodes function from the kLaR package that is suitable for categorical variable clusterting like our genres
genres = kmodes(apps2[,c(3:7,11)], modes = 10, iter.max = 10, weighted = FALSE)

#Each 
plot(jitter(apps2$Rating),col = genres$cluster)
points(genres$modes, col = 1:5, pch = 8)
genres$modes
genres$cluster


```
```{r}
genres = load("genres.rds")
```
However I'm loading the cluster that had the preferable generated genres to be used for the rest of the analysis.
```{r}
apps2 %>% mutate(cluster=genres$cluster) -> apps2
```
```{r}
clustapp = genres$modes
```

```{r}
apps2 %>% group_by(cluster, Genres) %>% count() %>% summarise(m=max(n)) %>% summarise(mm=max(m))  
```
```{r}
#Adding the new mega genres to the dataset
apps2 %>% mutate(True_Genre = case_when(
                                         cluster == 1 & Genres != clustapp$Genres[1] ~ clustapp$Genres[1],
                                         cluster == 2 & Genres != clustapp$Genres[2] ~ clustapp$Genres[2],
                                         cluster == 3 & Genres != clustapp$Genres[3] ~ clustapp$Genres[3],
                                         cluster == 4 & Genres != clustapp$Genres[4] ~ clustapp$Genres[4],
                                         cluster == 5 & Genres != clustapp$Genres[5] ~ clustapp$Genres[5],
                                         cluster == 6 & Genres != clustapp$Genres[6] ~ clustapp$Genres[6],
                                         cluster == 7 & Genres != clustapp$Genres[7] ~ clustapp$Genres[7],
                                         cluster == 8 & Genres != clustapp$Genres[8] ~ clustapp$Genres[8],
                                         cluster == 9 & Genres != clustapp$Genres[9] ~ clustapp$Genres[9],
                                         cluster == 10 & Genres != clustapp$Genres[10] ~ clustapp$Genres[10],
                                         TRUE ~ Genres)) -> apps3

```

```{r}
apps3 %>% group_by(True_Genre) %>% count()
```

##Regression Model with the new Genres:

```{r}
newreg = lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+True_Genre+Price, data = apps3, weights = Installs)
summary(newreg)
```
R-squared was lowered and for a good reason since we had an over abundance of genres previously that was inflating the value. 

```{r}
apps3 %>% filter(Rating >= 1 & Rating < 5) -> apps4 
reg1 = lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+True_Genre-1+Price, data = apps4, weights = Installs)
summary(reg1)
```
Here we opted to model app ratings that are in the range of [1,5) since it is a more realistic range. The extremely high R-squared is misleadinsignificant because majority of the apps are free. We also observe there is a negative slope for installs and positive slope for the number of reviews which confirms some of our hypotheses in the introduction where a decent app has a lot of installs but not enough reviews to have the score it truly deserves. As expected, the "Last Update" is also significant because it affects the overall rating of the app if the developers don't update to fix the bugs, so the more updated an app is the better the rating hence the positive slope. 

#Testing the accuracy of the Genre Classification
```{r}
genre_tree = rpart( cluster ~ Reviews+Installs+SIZE+Rating+`Last Update`, data = apps4, control = rpart.control(minsplit = 1, cp = 0) )

rpart.plot(genre_tree)
```
```{r}
apps4 %>% add_predictions(genre_tree, type = "class" ) %>% 
  xtabs( ~ pred + cluster, data = .) %>% prop.table()
 
```



```{r}
ggplot(reg1, aes(x=.fitted, y=.resid))+geom_point()+geom_smooth()
```
The residual plot doesn't look much different from before except it's less condensed at the top since we are not considering 5 star ratings.

#Making regression models for each genre of apps

```{r}
apps4 %>% filter(True_Genre == "Action") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Business") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Dating") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Education") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Finance") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Health & Fitness") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Lifestyle") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Productivity") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Shopping") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
apps4 %>% filter(True_Genre == "Tools") %>% lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+Price, data = ., weights = Installs) %>% tidy() 
```



##Sentiment Analysis
```{r}
reviews = read_csv("googleplaystore_user_reviews.csv")
(reviews = reviews %>% drop_na())
```


```{r}
reviews %>% ggplot(aes(x=Sentiment,y=Sentiment_Subjectivity))+geom_boxplot()
```

##Frequency of Words in Positive and Negative reviews
```{r}
(tidy_reviews <- reviews %>% filter(Sentiment != "Neutral") %>% group_by(Sentiment) %>% unnest_tokens(word,Translated_Review))
```

```{r}
#Counting the most common terms after filtering out common words
data("stop_words")
tidy_reviews = tidy_reviews %>% anti_join(stop_words)
```

```{r}
tidy_reviews %>% group_by(Sentiment) %>% count(word,sort = TRUE) %>% filter(n > 500) %>% 
  mutate(word=reorder(word,n)) %>% 
  ggplot(aes(word,n))+geom_col()+xlab(NULL)+coord_flip()
```

#WordCloud
```{r}
library(wordcloud)
```
```{r}
tidy_reviews %>% filter(Sentiment=="Positive") %>% count(word) %>% with(wordcloud(word,n,max.words = 175))
```
```{r}
tidy_reviews %>% filter(Sentiment=="Negative") %>% count(word) %>% with(wordcloud(word,n,max.words = 175))
```

```{r}
review_apps = apps4 %>% inner_join(reviews)
review_apps %>% filter(Sentiment != "Neutral") -> review_apps
```
```{r}
library(reshape2)
review_apps %>% filter(True_Genre=="Education") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Action") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Business") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Dating") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Finance") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Health & Fitness") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Lifestyle") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Productivity") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Shopping") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)

review_apps %>% filter(True_Genre=="Tools") %>% unnest_tokens(word,Translated_Review) %>% count(word,Sentiment,sort = TRUE) %>%  
  acast(word ~ Sentiment, value.var = "n", fill = 0) %>%
  comparison.cloud(colors = c("gray20", "gray80"),
                   max.words = 100)
  
```
```{r}
review_apps %>% group_by(Sentiment) %>% count()
review_apps %>% mutate(Sentiment3=cut(Sentiment_Polarity, breaks=c(-2,0,2))) %>% 
  glm(Sentiment3~Sentiment_Subjectivity,family = "binomial",data = .) %>% tidy()
```

```{r}
reg2 = lm(Rating~SIZE+I(log(Installs))+I(log(Reviews))+`Last Update`+True_Genre+Price+Sentiment, data = review_apps, weights = Installs)
summary(reg2)
```
Sentiment of the app is also significant to the rating, R-squared is misleading due to the sheer size of the data set.

```{r}

review_apps %>% mutate(rating_int=cut(Rating,breaks = c(0,1,2,3,4,5))) -> review_apps
```

```{r}
review_apps %>% filter(Sentiment != "Neutral") %>% ggplot(aes(rating_int, fill=Sentiment))+geom_bar()+facet_wrap(~True_Genre,scales = "free")
```

